// Oblivion Database Schema
// Reference: product/PRD.md - Section 3 (Hierarchy & Data Model)
//
// Hierarchy:
//   Tenant (Organization)
//     └── Group (Agent Team) - has Slack channel
//           ├── AgentGroupMembership (many-to-many)
//           └── Project (Work Scope) - has Slack channel, @tag routing
//                 └── Task (Unit of Work) - Slack thread, claimed by agent

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// =============================================================================
// LEVEL 0: TENANT (Organization)
// =============================================================================
// Top-level organization. All data is isolated at the tenant level (multi-tenancy).

model Tenant {
  id        String   @id @default(uuid())
  name      String   // e.g., "Acme Corp", "Startup Inc"
  slug      String   @unique // URL-friendly identifier
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  agents   Agent[]
  groups   Group[]
  projects Project[]

  @@map("tenants")
}

// =============================================================================
// LEVEL 1: GROUP (Agent Team)
// =============================================================================
// A permanent team of AI Agents with shared capabilities.
// Each Group has a dedicated Slack channel for team communication.
// Agents can join/leave multiple Groups dynamically.

model Group {
  id          String   @id @default(uuid())
  tenantId    String
  name        String   // e.g., "Backend Squad", "QA Team"
  slug        String   // URL-friendly identifier (unique per tenant)
  description String?

  // Slack integration (auto-created when group is created)
  slackChannelId   String? // Slack Channel ID
  slackChannelName String? // e.g., "#oblivion-backend-squad"

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant     Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  members    AgentGroupMembership[]
  projects   Project[]

  @@unique([tenantId, slug])
  @@index([tenantId])
  @@map("groups")
}

// =============================================================================
// AGENT <-> GROUP MEMBERSHIP (Many-to-Many)
// =============================================================================
// Tracks which agents belong to which groups.
// An agent can be in multiple groups; a group can have multiple agents.

model AgentGroupMembership {
  id       String   @id @default(uuid())
  agentId  String
  groupId  String
  role     String   @default("member") // "member", "lead"
  joinedAt DateTime @default(now())

  // Relations
  agent Agent @relation(fields: [agentId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([agentId, groupId])
  @@index([agentId])
  @@index([groupId])
  @@map("agent_group_memberships")
}

// =============================================================================
// LEVEL 2: PROJECT (Work Scope)
// =============================================================================
// A focused initiative within a Group.
// Each Project has a dedicated Slack channel and a unique @tag for ClickUp routing.
// Tasks are routed to Projects by parsing @tags in ClickUp task descriptions.

model Project {
  id          String   @id @default(uuid())
  groupId     String
  tenantId    String   // Denormalized for query efficiency
  name        String   // e.g., "Auth Refactor", "API v2"
  slug        String   // URL-friendly identifier
  description String?

  // ClickUp routing - the @tag used in task descriptions
  oblivionTag String?  @unique // e.g., "auth-refactor" (without @)

  // Slack integration (auto-created when project is created)
  slackChannelId   String? // Slack Channel ID
  slackChannelName String? // e.g., "#oblivion-auth-refactor"

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  group  Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tasks  Task[]

  @@unique([groupId, slug])
  @@index([tenantId])
  @@index([groupId])
  @@index([oblivionTag])
  @@map("projects")
}

// =============================================================================
// LEVEL 3: TASK (Unit of Work)
// =============================================================================
// The atomic unit of work that Agents claim and execute.
// Each Task is linked to a ClickUp task and a Slack thread.
// Agents CLAIM tasks (not auto-assigned).

model Task {
  id        String @id @default(uuid())
  projectId String

  // ClickUp side
  clickupTaskId String  @unique // ClickUp Task ID
  title         String? // Task title from ClickUp

  // Slack side (thread in project channel)
  slackChannelId String? // Channel where the thread lives
  slackThreadTs  String? // Thread timestamp (the "Root Message")

  // Task state
  status   TaskStatus @default(TODO)
  priority Int        @default(3) // 1=Urgent, 2=High, 3=Normal, 4=Low

  // Claiming
  claimedByAgentId String?   // Agent who claimed this task
  claimedAt        DateTime? // When the task was claimed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  project       Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  claimedByAgent Agent?  @relation("ClaimedTasks", fields: [claimedByAgentId], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([claimedByAgentId])
  @@index([status])
  @@index([slackChannelId, slackThreadTs])
  @@map("tasks")
}

enum TaskStatus {
  TODO
  CLAIMED      // Agent has claimed but not started
  IN_PROGRESS
  BLOCKED_ON_HUMAN
  DONE
}

// =============================================================================
// AGENT: AI Workers
// =============================================================================
// Registered AI agents that can connect to the platform.
// Each agent authenticates via OAuth2 Client Credentials.
// Agents can join multiple Groups and claim Tasks.

model Agent {
  id           String   @id @default(uuid())
  tenantId     String

  // Identity
  name         String   // e.g., "CodeReviewer", "BugFixer"
  description  String?  // Role description
  avatarUrl    String?  // Avatar for Slack messages

  // Capabilities (for smart task routing)
  capabilities String[] @default([]) // e.g., ["python", "testing", "devops"]

  // Authentication (OAuth2 Client Credentials)
  clientId     String   @unique // Public identifier
  clientSecret String   // Hashed secret

  // Status
  isActive   Boolean   @default(true)
  lastSeenAt DateTime? // Last heartbeat

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant           Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  groupMemberships AgentGroupMembership[] // Groups this agent belongs to
  claimedTasks     Task[]                 @relation("ClaimedTasks") // Tasks claimed by this agent

  @@index([tenantId])
  @@index([clientId])
  @@map("agents")
}
